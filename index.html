<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Two Suns</title>
  <style>
    html,body{height:100%}
    body{margin:0;overflow:hidden;background:#111;color:#fff;font-family:system-ui}
    #log{position:absolute;top:10px;left:10px;background:rgba(0,0,0,.6);
         padding:8px 10px;border-radius:6px;font-size:12px;max-width:360px;
         max-height:40vh;overflow:auto}
  </style>

  <!-- Import map so "three" works in browser ESM -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>
<div id="log">Init…</div>

<script>
  const logDiv=document.getElementById('log');
  const log=m=>{logDiv.innerHTML+='<br>'+m; console.log(m);}
  window.addEventListener('error', e=>log('❌ JS Error: '+e.message));
  window.addEventListener('unhandledrejection', e=>log('❌ Promise: '+(e.reason?.message||e.reason)));
</script>

<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
  import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';

  const log = (m)=>{document.getElementById('log').innerHTML+='<br>'+m; console.log(m);};

  // your GLB sits next to index.html
  const modelURL = './sun.glb?v=3';

  // scene / camera / renderer
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x111111);

  const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1000);
  camera.position.set(0, 1.2, 3.2);

  const renderer = new THREE.WebGLRenderer({antialias:true});
  if ('outputColorSpace' in renderer) renderer.outputColorSpace = THREE.SRGBColorSpace;
  else renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  // 3-point lighting
  const keyLight  = new THREE.DirectionalLight(0xffffff, 1.0); keyLight.position.set( 5, 5,  5); scene.add(keyLight);
  const fillLight = new THREE.DirectionalLight(0xffffff, 0.5); fillLight.position.set(-5, 2,  5); scene.add(fillLight);
  const backLight = new THREE.DirectionalLight(0xffffff, 0.7); backLight.position.set( 0, 5, -6); scene.add(backLight);

  // (optional) subtle ambient so shadows aren’t too harsh
  scene.add(new THREE.AmbientLight(0xffffff, 0.2));

  const loader = new GLTFLoader();

  let bigSun = null;
  let smallSun = null;

  log('Loading: '+modelURL);
  loader.load(
    modelURL,
    (gltf) => {
      // BIG SUN
      bigSun = gltf.scene;
      bigSun.position.set(0, 0, 0);
      bigSun.rotation.y = 0;
      scene.add(bigSun);

      // SMALL SUN (clone of the same model)
      smallSun = gltf.scene.clone(true);
      // make it smaller
      smallSun.scale.setScalar(0.35);
      // start it offset to the right
      smallSun.position.set(1.2, 0.2, 0);
      scene.add(smallSun);

      log('✅ Loaded big + small suns');
    },
    (xhr) => {
      if (xhr.lengthComputable) log('Progress: '+(xhr.loaded/xhr.total*100).toFixed(1)+'%');
    },
    (err) => log('❌ Error: '+(err?.message||err))
  );

  // animation parameters for the small sun
  const baseDistance = 1.0;     // minimum distance from the big sun
  const amplitude    = 0.9;     // how far it moves in/out
  const speed        = 1.2;     // oscillations per second
  const lateralSway  = 0.35;    // slight sideways sway to make motion organic
  const verticalBob  = 0.15;    // slight up/down bobbing

  function animate(timeMs){
    requestAnimationFrame(animate);
    const t = timeMs * 0.001; // seconds

    // gentle rotation so they feel alive
    if (bigSun)   bigSun.rotation.y   += 0.005;
    if (smallSun) smallSun.rotation.y += 0.01;

    // move the small sun toward and away from the big one repeatedly
    if (smallSun) {
      // distance along the X axis oscillates with sine
      const dist = baseDistance + amplitude * (0.5 + 0.5 * Math.sin(t * Math.PI * 2 * speed) - 0.5);
      // organic path: slight lateral sway (Z) and vertical bob (Y)
      const sway = lateralSway * Math.sin(t * 2.3);
      const bob  = verticalBob  * Math.sin(t * 1.7);

      smallSun.position.set(dist, bob, sway);
    }

    controls.update();
    renderer.render(scene, camera);
  }
  animate(0);

  // resize
  addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });
</script>
</body>
</html>
