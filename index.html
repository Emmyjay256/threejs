<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Two Suns – Progressive Load</title>
  <style>
    html,body{height:100%}
    body{margin:0;overflow:hidden;background:#0b0b0b;color:#fff;font-family:system-ui}

    /* HUD */
    #hud{position:absolute;inset:0;pointer-events:none;display:flex;align-items:flex-start;justify-content:center}
    #panel{margin-top:14px;background:rgba(0,0,0,.55);backdrop-filter:saturate(140%) blur(6px);
           border-radius:10px;padding:10px 12px;font-size:12px;line-height:1.4;max-width:380px}
    #bar{height:4px;background:rgba(255,255,255,.15);border-radius:2px;overflow:hidden;margin-top:6px}
    #fill{height:100%;width:0%;background:linear-gradient(90deg,#9cf,#9f9);transition:width .15s ease}
    #small{opacity:.8;font-size:11px;color:#ddd}

    /* We’ll blur the canvas while loading via JS by editing this filter */
    canvas{display:block;filter:blur(10px)}
    .hidden{display:none}
  </style>

  <!-- Import map so "three" works in-browser -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>
<div id="hud">
  <div id="panel">
    <div><b>Loading scene…</b> <span id="pct">0%</span></div>
    <div id="small">Preparing lights & placeholders…</div>
    <div id="bar"><div id="fill"></div></div>
  </div>
</div>

<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
  import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';

  // ---------- UI helpers ----------
  const pctEl = document.getElementById('pct');
  const fillEl = document.getElementById('fill');
  const smallEl = document.getElementById('small');
  const panelEl = document.getElementById('panel');
  const setProgress = (p)=>{ const v=Math.max(0,Math.min(100,p)); pctEl.textContent = v.toFixed(0)+'%'; fillEl.style.width = v+'%'; };

  // ---------- Scene / camera / renderer ----------
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b0b0b);

  const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1000);
  camera.position.set(0, 1.2, 3.2);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  if ('outputColorSpace' in renderer) renderer.outputColorSpace = THREE.SRGBColorSpace;
  else renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  // ---------- 3-point lights + soft ambient ----------
  const key   = new THREE.DirectionalLight(0xffffff, 1.0); key.position.set( 5, 5,  5);
  const fill  = new THREE.DirectionalLight(0xffffff, 0.55); fill.position.set(-5, 2,  5);
  const back  = new THREE.DirectionalLight(0xffffff, 0.75); back.position.set( 0, 5, -6);
  const amb   = new THREE.AmbientLight(0xffffff, 0.2);
  scene.add(key, fill, back, amb);

  // ---------- Placeholders (instant) ----------
  // Big placeholder
  const placeholderMat = new THREE.MeshStandardMaterial({
    color: 0xffcc66,
    emissive: 0xffaa33,
    emissiveIntensity: 0.6,
    roughness: 0.6,
    metalness: 0.0
  });
  const bigPH = new THREE.Mesh(new THREE.SphereGeometry(0.7, 32, 16), placeholderMat);
  bigPH.name = 'bigPH';
  scene.add(bigPH);

  // Small placeholder
  const smallPH = new THREE.Mesh(new THREE.SphereGeometry(0.25, 24, 12),
    new THREE.MeshStandardMaterial({ color: 0xffe199, emissive: 0xffcc66, emissiveIntensity: 0.7, roughness: 0.5 })
  );
  smallPH.position.set(1.2, 0.2, 0);
  smallPH.name = 'smallPH';
  scene.add(smallPH);

  smallEl.textContent = 'Placeholders visible… loading real models';

  // ---------- Load real GLB and blur-up ----------
  const modelURL = './sun.glb?v=7';
  const loader = new GLTFLoader();

  let bigSun = null;
  let smallSun = null;
  let reveal = 0; // 0..1 crossfade from placeholder -> real

  // canvas blur control
  let currentBlur = 10; // px, start blurry
  function applyBlur(px){ renderer.domElement.style.filter = `blur(${px}px)`; }

  loader.load(
    modelURL,
    (gltf) => {
      // BIG sun
      bigSun = gltf.scene;
      bigSun.traverse(o=>{
        if (o.isMesh && o.material) { o.material = o.material.clone(); o.material.transparent = true; o.material.opacity = 0; }
      });
      scene.add(bigSun);

      // SMALL sun (clone)
      smallSun = gltf.scene.clone(true);
      smallSun.scale.setScalar(0.35);
      smallSun.position.copy(smallPH.position);
      smallSun.traverse(o=>{
        if (o.isMesh && o.material) { o.material = o.material.clone(); o.material.transparent = true; o.material.opacity = 0; }
      });
      scene.add(smallSun);

      smallEl.textContent = 'Model loaded. Revealing…';
      // start crossfade
      reveal = 0.001;
    },
    (xhr) => {
      if (xhr.lengthComputable) {
        const p = (xhr.loaded / xhr.total) * 100;
        setProgress(p);
        // ease blur down with progress (10px -> 0px)
        currentBlur = 10 * (1 - p/100);
        applyBlur(currentBlur);
      } else {
        smallEl.textContent = `Loaded ${xhr.loaded} bytes…`;
      }
    },
    (err) => {
      smallEl.textContent = 'Load error: ' + (err?.message || err);
    }
  );

  // ---------- Motion params for small sun ----------
  const baseDistance = 1.0;
  const amplitude    = 0.9;
  const speed        = 1.2;
  const lateralSway  = 0.35;
  const verticalBob  = 0.15;

  // ---------- Animate ----------
  function animate(tMs){
    requestAnimationFrame(animate);
    const t = tMs * 0.001;

    // Placeholder emissive pulse (so it feels alive before real model)
    const pulse = 0.6 + Math.sin(t*2.0)*0.08;
    placeholderMat.emissiveIntensity = pulse;

    // Spin everything a bit
    bigPH.rotation.y   += 0.004;
    smallPH.rotation.y += 0.008;
    if (bigSun)   bigSun.rotation.y   += 0.005;
    if (smallSun) smallSun.rotation.y += 0.01;

    // Small body motion (both placeholder and real one share the same path)
    const dist = baseDistance + amplitude * (0.5 + 0.5 * Math.sin(t * Math.PI * 2 * speed) - 0.5);
    const sway = lateralSway * Math.sin(t * 2.3);
    const bob  = verticalBob  * Math.sin(t * 1.7);
    smallPH.position.set(dist, bob, sway);
    if (smallSun) smallSun.position.set(dist, bob, sway);

    // If we’re revealing, crossfade placeholder -> real and finish blur-up
    if (reveal > 0 && bigSun && smallSun) {
      // ease reveal up
      reveal = Math.min(1, reveal + 0.03);

      // material opacity
      const phOpacity = 1 - reveal; // placeholders fade out
      const realOpacity = reveal;   // real models fade in

      bigSun.traverse(o=>{ if (o.isMesh && o.material) o.material.opacity = realOpacity; });
      smallSun.traverse(o=>{ if (o.isMesh && o.material) o.material.opacity = realOpacity; });

      bigPH.visible = phOpacity > 0.02;
      smallPH.visible = phOpacity > 0.02;

      // finish blur to 0 as we reveal
      currentBlur = Math.max(0, currentBlur - 0.6);
      applyBlur(currentBlur);

      // when fully revealed, hide HUD
      if (reveal === 1) {
        panelEl.classList.add('hidden');
        applyBlur(0);
      }
    }

    controls.update();
    renderer.render(scene, camera);
  }
  applyBlur(currentBlur);
  animate(0);

  // ---------- Resize ----------
  addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  // Start at a non-zero progress so bar isn’t empty if cached
  setProgress(5);
</script>
</body>
</html>
